# 실전 자바 - 중급2편
***
## 제네릭 
제네릭을 사용하면 코드 재사용과 타입 안정성이라는 두 마리 토끼를 한 번에 잡을 수 있다.
```java
public class GenericBox<T> {

    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```
* `<>`를 사용한 클래스를 제네릭 클래스라 한다. 이 기호(`<>`)는 보통 다이아몬드라 한다.
* 제네릭 클래스를 사용할 때는 Integer, String 같은 타입을 미리 결정하지 않는다.
* 대신 클래스명 오른쪽에 `<T>`와 같이 선언하면 제네릭 클래스가 된다. 여기서 `T`를 타입 매개변수라 한다. 이 타입 매개변수는 이후에 Integer, String으로 변할 수 있다.
* 클래스 내부에 `T` 타입이 필요한 곳에 `T value`와 같이 타입 매개변수를 적어두면 된다.

### 타입 추론
```java
 GenericBox<Integer> integerBox = new GenericBox<Integer>(); // 타입 선언
 GenericBox<Integer> integerBox = new GenericBox<>(); // 타입 추론
```

## 제네릭 용어와 관례
제네릭의 핵심은 사용할 타입을 미리 결정하지 않는 다는 점이다. 클래스 내부에서 사용하는 타입을 클래스를 정의하는 시점에 결정하는 것이 아니라 실제 사용하는 생성 시점에 타입을 경정하는 것이다.

### 용어 정리
* 제네릭(Generic) 단어
  * 제네릭이라는 단어는 일반적인, 범용적인이라는 영어 단어이다.
  * 풀어보면 특정 타입에 속한 것이 아니라 일반적으로, 범용적으로 사용할 수 있다는 뜻이다.
* 제네릭 타입(Generic Type)
  * 클래스나 인터페이스를 정의할 때 타입 매개변수를 사용하는 것을 말한다.
  * 제네릭 클래스, 제네릭 인터페이스를 모두 합쳐서 제네릭 타입이라 한다.
* 타입 매개변수(Type Parameter)
  * 제네릭 타입이나 메서드에서 사용되는 변수로, 실제 타입으로 대체 된다.
* 타입 인자(Type argument)
  * 제네릭 타입을 사용할 때 제공되는 실제 타입이다.

### 제네릭 명명 관례
타입 매개변수는 일반적인 변수명처럼 소문자로 사용해도 문제는 없다.
하지만 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.
* E - Element
* K - Key
* N - Number
* T - Type
* V - Value
* S,U,V etc. - 2nd, 3rd, 4th types

### 제네릭 기타
다음과 같이 한번에 여러 타입 매개변수를 선언할 수 있다.
```java
class Data<K, V> {
    ...
}
```

> 타입 인자로 기본형은 사용할 수 없다.

### 타입 매개변수 제한
타입 매개변수를 특정 타입으로 제한할 수 있다.

```java
import generic.animal.Animal;

public class AnimalHospitalV3<T extends Animal> {

  private T animal;

  public void set(T animal) {
    this.animal = animal;
  }

  public void checkup() {
    System.out.println("동물 이름: " + animal.getName());
    System.out.println("동물 크기: " + animal.getSize());
    animal.sound();
  }

  public T bigger(T target) {
    return animal.getSize() > target.getSize() ? animal : target;
  }
}
```
타입 매개변수 `T`를 `Animal`과 그 자식만 받을 수 있도록 제한을 두는 것이다. 즉 `T`의 상한이 `Animal`이 되는 것이다.
자바 컴파일러는 `T`에 입력될 수있는 값의 범위를 예측할 수 있다.
따라서 `Animal`이 제공하는 `getName()`, `getSize()` 같은 기능을 사용할 수 있다.

### 제네릭 메서드
   
* 정의: `<T> T genericMethod(T t)`
* 타입 인자 전달: 메서드를 호출하는 시점
  * 예) GenericMethod.<Integer>genericMethod(i)


* 제네릭 메서드는 클래스 전체가 아니라 특정 메서드 단위로 제네릭을 도입할 때 사용한다.
* 제네릭 메서드를 정의할 때는 메서드의 반환 타입 왼쪽에 다이아몬드를 사용해서 `<T>`와 같이 타입 매개변수를 적어준다.
* 제네릭 메서드는 메서드를 실제 호출하는 시점에 다이아몬드를 사용해서 `<Integer>`와 같이 타입을 정하고 호출한다.

### 타입 매개변수 제한
제네릭 메서드도 제네릭 타입과 마찬자기로 타입 매개변수를 제한할 수 있다.
```java
public static <T extends Number> T numberMethod(T obj) {
    System.out.println("bound print: " + obj);
    return obj;
}
```

### 와일드 카드
이미 만들어진 제네릭 타입을 활용할 때 사용한다.
* 와일드 카드는 제네릭 타입이나 제네릭 메서드를 정의할 때 사용하는 것이 아니다.   
`Box<Dog>`, `Box<Cat>`처럼 타입인자가 정해진 제네릭 타입을 전달 받아서 활용할 때 사용한다.
* 와일드 카드인 `?`는 모든 타입을 다 받을 수 있다는 뜻이다.
  * `?`는 다음과 같다. `<? extends Object>`

#### 제네릭 메서드 VS 와일드 카드
제네릭 메서드는 특정 시점에 타입 매개변수에 타입 인자를 전달해서 타입을 결정해야 한다. 이 과정은 매우 복잡하다.
반면에 와일드 카드는 일반적인 메서드에 사용할 수 있고, 단순히 매개변수로 제네릭 타입을 받을 수 있는 것 뿐이다.
제네릭 메서드처럼 타입을 겨정하거나 복잡하게 작동하지않는다. 제네릭 타입이나 제네릭 메서드를 정의하는게 꼭 필요한 상황이 아니라면
더 단순한 와일드 카드 사용을 권장한다.

#### 타입 이레이저
제네릭은 자바 컴파일 단계에서만 사용되고, 컴파일 이후에는 제네릭 정보가 삭제 된다.
제네릭에 사용한 타입 매개변수가 모드 사라지는 것이다.

***

## 컬렉션 프레임워크 - ArrayList
### 배열의 특징 - 배열과 인덱스
* 배열에서 자료를 찾을 때 인덱스(index)를 사용하면 매우 빠르게 자료를 찾을 수 있다.
* 인덱스를 통한 입력, 변경, 조회의 경우 한번의 계산으로 자료의 위치를 찾을 수 있다.

#### 배열의 검색
배열에 들어있는 데이터를 찾는 것을 검색이라 한다.
배열에 들어있는 데이터를 검색할 때는 배열에 들어있는 데이터를 하나하나 비교해야 한다.
이때는 이전과 같이 인ㄷ게스를 사용해서 한번에 찾을 수 없다.
대신 배열안에 들어있는 데이터를 하나하나 확인해야 한다.
따라서 평균적으로 볼 때 배열의 크기가 클 수록 오랜 시간이 걸린다.

### 빅오(O) 표기법
빅오(Big O) 표기법은 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식이다.
이는 특히 알고리즘이 처리해야할 데이터의 양이 증가할 때, 그 알고리즘이 얼마나 빠르게 실행되는지 나타낸다.
여기서 중요한 것은 알고리즘의 정확한 실행 시간을 계산하는 것이 아니라, 데이터 양의 증가에 따른 성능의 변화 추세를 이해하는 것이다.

#### 빅오 표기법의 예시
* O(1) - 상수시간: 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정하다.
  * 예) 배열에서 인덱스를 사용하는 경우
* O(n) - 선형 시간: 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가한다.
  * 예) 배열의 검색, 배열의 모든 요소를 순회하는 경우
* O(n²) - 제곱 시간: 알고리즘의 실행 시간이 입력 데이터의 크기에 제곱에 비례하여 증가한다.
  * 예) 보통 이중 루프를 사용하는 알고리즘에서 나타남
* O(log n) - 로그 시간: 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
  * 예) 이진 탐색
* O(n long n) - 선형 로그 시간: 
  * 예) 많은 효율적인 정렬 알고리즘들

### 배열의 특징2 - 데이터 추가
추가는 기존 데이터를 유지하면서 새로운 데이터를 입력하는 것을 뜻한다.
데이터를 추가하려면 새로운 데이터를 입력할 공간을 확보해야 한다.

#### 배열에 데이터를 추가할 때 위치에 따른 성능 변화
* 배열의 첫번째 위치에 추가
  * 배열의 첫번째 위치를 찾는데 인덱스를 사용하므로 O(1)이 걸린다.
  * 모든 데이터를 배열의 크기만큼 한 칸씩 이동해야 한다. 따라서 O(n)만큼 연산이 걸린다.
  * O(1+n)-> O(n)이 된다.
* 배열의 중간 위치에 추가
  * 배열의 위치를 찾는데 O(1)이 걸린다.
  * index의 오른쪽에 있는 데이터를 모두 한 칸씩 이동해야 한다. 따라서 평균 연산은 O(n/2)이 된다.
  * O(1+n/2)->O(n)이 된다.
* 배열의 마지막 위치에 추가
  * 이 경우 배열이 이동하지 않고 배열의 길이를 사용하면 마지막 인덱스에 바로 접근할 수 있으므로 한번의 계산으로 위치를 찾을 수 있고, 기존 배열이 이동하지 않으므로 O(1)이 된다.
 
#### 배열의 한계
배열은 가장 기본적인 자료 구조이고, 특히 인덱스를 사용할 때 최고의 효율이 나온다.
하지만 이런 배열에는 큰 단점이 있다. 바로배열의 크기를 배열을 생성하는 시점에 정해야 한다는 점이다.

### 배열리스트
배열의 한계를 해소하고 동적으로 데이터를 추가할 수 있는 자료 구조를 List라 한다.

#### List 자료 구조
순서가 있고, 중복을 허용하는 자료 구조를 리스트라 한다.

### 동적 배열리스트
* 동적 배열리스트는 배열의 크기를 미리 정하지 않아도 된다.
* 배열의 여유 공간이 부족하면 자동으로 배열의 크기를 늘린다.
***
## 컬렉션 프레임워크 - LinkedList
### 노드와 연결
배열은 필요한 배열의 크기를 미리 확보해야 한다. 데이터가 얼마나 추가 될지 알 수 없는 경우
나머지 공간은 사용되지 않고 낭비된다. 배열의 앞이나 중간에서 데이터를 추가하거나 삭제할 경우 많은 양의 데이터들을 이동해야 하기 때문에
성능이 좋지 않다.

낭비되는 메모리 없이 딱 필요한 만큼만 메모리를 확보해서 사용하고, 또 앞이나 중간에 데이터를 추가, 삭제 할때도 효율적인 자료구조가 있다.
바로 노드를 만들고 각 노드들을 연결하는 방식이다.

* 노드는 내부 데이터와 다음 노드에 대한 참조를 가지고 있다.
* 각각의 노드가 참조를 통해 연결되어있다.
* 데이터를 추가할 때 동적으로 필요한 만큼의 노드만 만들어서 연결하면 된다.
  * 물론 `next` 필드를 통해 참조값을 보관해야 하기 때문에 배열과 비교해서 추가적인 메모리가 필요하다.
***
## 컬렉션 프레임워크 - List
### 리스트 추상화
순서가 있고 중복을 허용하는 자료구조를 `List`라 한다.
`ArrayList`와 `LinkedList`는 내부 구현만 다를 뿐 같은 기능을 제공하는 리스트이다.
이 둘의 공통 기능을 인터페이스로 추상화한다면 다형성을 활용할 수 있다.

### 컬렉션 프레임워크
#### Collection 인터페이스
`Collection`인터페이스는 `java.util`패키지의 컬렉션 프레임워크의 핵심 인터페이스 중 하나이다.
이 인터페이스는 자바에서 다양한 컬렉션, 즉 데이터 그룹을 다루기 위한 메서드를 정의 한다.
`Collection` 인터페이스는 `List`, `Set`, `Queue`와 같은 다양한 하위 인터페이스와 함께 사용되며,
이를 통해 데이터를 리스트, 세트, 큐 등의 형태로 관리할 수 있다.

#### List 인터페이스
`List`인터페이스는 `java.util` 패키지에 있는 컬렉션 프레임워크의 일부다.
`List`는 객체들의 순서가 있는 컬렉션을 나타내며, 같은 객체의 중복 저장을 허용한다.
이 리스트는 배열과 비슷하지만, 크기가 동적으로 변화하는 컬렉셔늘 다룰 때 유연하게 사용할 수 있다.

`List`인터페이스는 `ArrayList`, `LinkedList`와 같은 여러 구현 클래스를 가지고 있으며, 각 클래스는 `List`인터페이스의 메서드를 구현한다.
***
## 컬렉션 프레임워크 - 해시
### Set
* 정의: 유일한 요소들의 컬렉션이다.
* 특징
  * 유일성: 중복된 요소가 존재하지 않는다. 요소를 추가할 때 이미 존재하는 요소면 무시 된다.
  * 순서 미보장: 요소를 출력할 때 입력 순서와 다를 수 있다.
  * 빠른 검색: 요소의 유무를 빠르게 확인 할 수 있도록 최적화 되어있다.
* 용도: 중복을 허용하지 않고, 요소의 유무만 중요한 경우에 사용된다.

### 해시 알고리즘
해시(Hash) 알고리즘을 사용하면 데이터를 찾는 검색 성능을 평균 O(1)로 비약적으로 끌어올릴 수 있다.

### 해시 인덱스
배열의 인덱스로 사용할 수 있도록 원래의 값을 계산한 인덱스를 해시 인덱스라 한다.

### 해시 충돌
통계적으로 입력한 데이터의 수가 배열의 크기를 75% 넘지 않으면 해시 인덱스는 자주 총돌하지 않는다.
반대로 75%를 넘으면 자주 총돌하기 시작한다.
상황에 따라 다르겠지만 보통 75%를 적절한 크기로 보고 기준으로 잡는 것이 효과적이다. 

### 해시 함수(Hash Function)
* 해시 함수는 임의의 길이의 데이터를 입력 받아, 고정된 길이의 해시값(해시 코드)을 출력하는 함수이다.
  * 여기서 의미하는 고정된 길이는 저장 공간의 크기를 뜻한다. 예를 들어 `int`형 `1`, `100`은 둘다 4byte를 차지한다.
* 같은 데이터를 입력하면 항상 같은 해시 코드가 출력된다.
* 다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다. 이것을 해시 충돌이라 한다.
  * 해시 충돌의 예
    * "BC" -> B(66) + C(67) = 133
    * "AB" -> A(65) + D(68) = 133
### 해시 코드
* 해시 코드는 데이터를 대표하는 값을 뜻한다. 보통 해시 함수를 통해 만들어진다.

### 해시 인덱스
* 데이터의 저장 위치를 결정하는데, 주로 해시 코드를 사용해 만든다.
* 보통 해시 코드의 결과에 배열의 크기를 나누어 구한다.

### 자바의 hashCode()
해시 자료 구조에 저장하려면 모든 객체가 숫자 해시 코드를 제공할 수 있어야 한다.

#### Object.hashCode()
자바는 모든 객체가 자신만의 해시 코드를 표현할 수 있는 기능을 제공한다. `Object`에 있는 `hashCode()`메서드이다.
* 이 메서드를 그대로 사용하기 보다는 보통 재정의(오버라이딩)해서 사용한다.
* 이 메서드의 기본 구현은 객체의 참조값을 기반으로 해시코드를 생성한다.
* 쉽게 이야기해서 객체의 인스턴스가 다르면 해시 코드도 다르다.

### equals, hashCode의 중요성
해시 자료 구조를 사용하려면 `hashCode()`도 중요하지만, 해시 인덱스가 충돌할 경우를 대비해 `equals()`도 반드시 재정의해야 한다.
해시 인덱스가 충돌할 경우 같은 해시 인덱스에 있는 데이터를 하나하나 비교해서 찾아야 한다. 이때 `equals()`를 사용해서 비교한다.

## 컬렉션 프레임워크 - Set
1. HashSet
* 구현: 해시 자료 구조를 사용해서 요소를 저장한다.
* 순서: 요소들은 특정한 순서 없이 지정된다. 즉, 요소를 추가한 순서를 보장하지 않는다.
* 시간 복잡도: `HashSet`의 주요 연산(추가, 삭제, 검색)은 평균 O(1) 시간 복잡도를 가진다.
* 용도: 데이터의 유일성만 중요하고 순서가 중요하지 않은 경우에 적합하다.

2. LinkedHashSet
* 구현: `LinkedHashSet`은 `HashSet`에 연결 리스트를 추가해서 요소들의 순서를 유지한다.
* 순서: 요소들은 추가된 순서대로 유지된다. 즉, 순서대로 조회 시 요소들이 추가된 순서로 반환된다.
* 시간 복잡도: `LinkedHashSet`도 `HashSet`과 마찬가지로 주로 연산에 대해 평균 O(1) 시간 복잡도를 가진다.
* 용도: 데이터의 유일성과 함께 산입 순서를 유지해야 할 때 적합하다.
* 참고: 연결 링크를 유지해야 하기 때문에 `HashSet`보다는 조금 더 무겁다.

3. TreeSet
* 구현: `TreeSet`은 이진 탐색 트리를 개선한 레드-블랙 트리를 내부에서 사용한다.
* 순서: 요소들은 정렬된 순서로 저장된다. 순서의 기준은 비교자(Comparator)로 변경할 수 있다.
* 시간 복잡도: 주요 연산들은 O(log n)의 시간 복잡도를 가진다 따라서 `HashSet`보다는 느리다.
* 용도: 데이터들을 정렬된 순서로 유지하면서 집합의 특성을 유지해야 할 때 사용한다. 예를 들어, 범위 검색이나 정렬된 데이터가 필요한 경우에 유용하다.

#### 자바 HashSet과 최적화
* 해시 기반 자료 구조를 사용하는 경우 통계적으로 입력한 데이터의 수가 배열의 크기 75% 정도 넘어가면 해시 인덱스가 자주 충돌한다. 따라서 75%가 넘어가면 성능이 떨어지기 시작한다.
  * 해시 충돌로 같은 해시 인덱스에 들어간 데이터를 검색하려면 모두 탐색해야 한다. 따라서 성능이 O(n)으로 좋지 않다
* 하지만 데이터가 동적으로 계속 추가되기 때문에 적절한 배열의 크기를 정하는 것은 어렵다.
* 자바의 `HashSet`은 데이터의 양이 배열 크기의 75%를 넘어가면 배열의 크기를 2배로 늘리고 2배 늘어난 크기를 기준으로 모든 요소에 해시 인덱스를 다시 적용한다(rehashing).
  * 해시 인덱스를 다시 적용하는 시간이 걸리지만, 결과적으로 해시 충돌이 줄어든다.
* 자바 HashSet의 기본 크기는 `16`이다.

***

## 컬렉션 프레임워크 - Map, Stack, Queue
Map
* 키-값의 쌍을 저장하는 자료 구조이다.
* 키는 맵 내에서 유일해야 한다. 키를 통해서 값을 빠르게 검색할 수 있다.
* 키는 중복될 수 없지만, 값은 중복될 수 있다.
* Map은 순서를 유지하지 않는다.

1. HashMap
* 구조: `HashMap`은 해시를 사용해서 요소를 저장한다 키(Key) 값은 해시 함수를 통해 해시코드로 변환되고, 이 해시 코드는 데이터를 저장하고 검색하는 데 사용된다.
* 특징: 삽입, 삭제 검색 작업은 해시 자료 구조를 사용하므로 일반적으로 상수 시간 O(1)의 복잡도를 가진다.
* 순서: 순서를 보장하지 않는다.

2. LinkedHashMap
* 구조: `LinkedHashMap`은 `HashMap`과 유사하지만, 연결 리스트를 사용하여 삽입 순서 또는 최근 접근 순서에 따라 요소를 유지한다.
* 특징: 입력 순서에 따라 순회가 가능하다. `HashMap`과 같지만 입력 순서를 링크로 유지해야 하므로 조금 더 무겁다.
* 성능: `HashMap`과 유사하게 대부분의 작업은 O(1)의 시간 복잡도를 가진다.
* 순서: 입력 순서를 보장한다.

3. TreeMap
* 구조: `TreeMap`은 레드-블랙 트리를 기반으로 한 구현이다.
* 특징: 모든 키는 자연 순서 또는 생성자에 제공된 `Comparator`에 의해 정렬된다.
* 성능: `get`, `put`, `remove`와 같은 주요 작업들은 O(log n)의 시간 복잡도를 가진다.
* 순서: 키는 정렬된 순서로 저장된다.

Dequeue와 Stack, Queue
`Dequeue`는 양쪽으로 데이터를 입력하고 출력 할 수 있으므로, 스택과 큐의 역할을 모두 수행할 수 있다.
`Dequeue`를 `Stack`과 `Queue`로 사용하기 위한 메서드 이름까지 제공한다.

Dequeue
데이터 추가: `offerFirst()`, `offerLast()`
데이터 제거: `pollFirst()`, `pollLast()`

Dequeue - Stack
데이터 추가: `push()`
데이터 제거: `pop()`

Dequeue - Queue
데이터 추가: `offer()`
데이터 제거: `poll()`

***

## 컬렉션 프레임워크 - 순회, 정렬
### Iterable, Iterator
`Iterable` 인터페이스의 주요 메서드
```java
public interface Iteralbe<T> {
    Iterator<T> iterator();
}
```
* 단순히 `Iterator` 반복자를 반환한다.

`Iterator` 인터페이스의 주요 메서드
```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
}
```
* `hasNext()`: 다음 요소가 있는지 확인한다. 다음 요소가 없으면 false를 반환한다.
* `next()`: 다음 요소를 반환한다. 내부에 있는 위치를 다음으로 이동한다.

### Comparable, Comparator
자바가 기본으로 제공하는 `Integer`, `String` 같은 객체를 제외하고 `MyUser`와 같은 직접 만든 객체를 정렬하려면
두 객체중에 어떤 객체가 더 큰지 알려줄 방법이 있어야 한다. 이때는 `Comparable` 인터페이스를 구현하면 된다.
```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```
* 자신과 인수로 넘어온 객체를 비교해서 반환하면 된다.
  * 현재 객체가 인수로 주어진 객체보다 더 작으면 음수, 예(-1)
  * 두 객체의 크기가 같으면 0
  * 현재 객체가 인수로 주어진 객체보다 더 크면 양수, 예(1)

#### Arrays.sort(array)
기본 정렬을 시도한다. 이때 객체가 스스로 가지고 있는 `Comparable`인터페이스를 사용해서 비교한다.

#### 다른 방식으로 정렬
객체가 가지고 있는 `Comparable` 기본 정렬이 아니라 다른 정렬을 사용하고 싶다면 `Compartor<T>`를 구현한 클래스를 만들어 사용하면된다.

#### Arrays.sort(array, Comparator)
기본 정렬이 아니라 정렬 방식을 지정하고 싶다면 `Arrays.sort()`의 인수로 비교자(`Comparator`)를 만들어 넘겨주면 된다.
비교자를 따로 전달하면 객체가 기본으로 가지고 있는 `Comparable`을 무시하고 전달 받은 비교자를 사용한다.

> 주의

만약 `Comparble`도 구현하지 않고, `Comparator`도 제공하지 않으면 다음과 같은 런타임 오류가 발생한다.
```java
java.lang.ClassCastException: class collection.compare.MyUser cannot be cast to class java.lang.Comparable
```
`Compartor`가 없으니, 객체가 가지고 있는 기본 정렬을 사용해야 한다. 이때 `Comparable`을 사용하게 되는데 `Comparable`가 없어 예외가 발생한다.
